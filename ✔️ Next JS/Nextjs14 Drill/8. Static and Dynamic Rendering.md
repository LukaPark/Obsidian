
- 이전 단계의 문제
	1. 데이터 요청으로 의도치 않은 폭포수 형태 생성.
	2. 대시보드 페이지는 정적이므로 데이터 업데이트가 앱에 반영되지 않음.

1. 정적 렌더링? 앱 성능 향상 방법.
2. 동적 렌더링? 사용 하는 방법.
3. 대시보드를 동적으로 만드는 다양한 접근 방식.
4. 요청시 데이터 가져오기에 대한 제한 사항.

# 정적 렌더링. *Static Rendering*

- 정적 렌더링을 사용하면, 빌드 시(배포 시점) 또는 재검증 중에 데이터 가져오기 및 렌더링이 서버에서 발생. 결과는 CDN(*Content Delivery Network*)에 배포 및 캐싱(저장) 됩니다.

- 정적 렌더링의 이점.
	- **더 빠른 웹사이트 구축**: 사전 렌더링 된 콘텐츠를 캐싱. 
	- **서버 로드 감소**: 콘텐츠가 캐싱되기 때문에 서버는 각 사용자 요청에 대해 콘텐츠를 동적으로 생성할 필요 X
	- **SEO**: 사전 렌더링 된 콘텐츠는 페이지가 로드될 때 이미 콘텐츠를 사용할 수 있으므로, 검색엔진 크롤러가 index를 생성하기 더 쉬워짐. 이를 통해 검색 엔진 노출에 유리.
- 정적 렌더링은 블로그 게시물이나 제품 페이지와 같이 사용자 간에 공유되는 데이터가 없는 UI에 유리함.


# 동적 렌더링. *Dynamic Rendering*

- **동적 렌더링**을 사용 시, 각 사용자의 콘텐츠가 서버에서 렌더링. 
- **동적 렌더링**의 이점.
	1. **실시간 데이터** - 앱은 실시간 또는 자주 업데이트되는 데이터를 출력.
	2. **사용자 별 콘텐츠** - 사용자 상호 작용을 기반으로 데이터가 업데이트 되므로, 동적 렌더링을 통해 개인화된 대시보드나 사용자 프로필과 같은 사용자별 콘텐츠를 더 쉽게 제공.
	3. **요청 시간 정보** - 동적 렌더링을 사용하면, 쿠키나 URL Search Parameter 와 같이 요청 시간에만 알 수 있는 정보에 엑세스 할 수 있음.

# 대시보드를 동적으로 만들기.

- 기본적으로 @vercel/postgres 는 자체 캐싱 의미 체계를 설정하지 않음. 이를 통해 프레임워크는 자체 정적 및 동적 동작을 설정할 수 있음.
	- 서버 구성 요소 내부에서 호출되는 unstable_noStore (Next.js API)나 데이터 가져오기 기능을 사용하여 정적 렌더링을 거부할 수 있음.
	- **Cache-Control: no-store** - 캐싱을 금지.

	참고: ==unstable_noStore== 는 실험적인 API이며 향후 변경 가능성 존재, 
		export const dynamic = "force-dynamic" 을 통해 안정적인 세그먼트 구성 옵션을 사용 가능.
		https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config


# 느린 데이터 가져오기 시뮬레이션.

- 하나의 데이터 요청이 다른 데이터들보다 느리다면,
- 만약 한가지 요청이 3초 정도 걸린다면, 나머지 모든 요청들은 완료되더라도 같이 3초를 기다려야 하고, 그 동안 화면에는 아무것도 보이지 않게 됨.
- 