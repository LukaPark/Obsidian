
1. API, ORM, SQL 등 데이터를 가져오는 몇 가지 접근 방식에 대한 이해.
2. 서버 구성 요소가 백엔드 리소스에 보다 안전하게 액세스하는 방법.
3. 네트워크 폭포수란 ?
4. JS 패턴을 사용하여 병렬 데이터 가져오기를 구현하는 방법.

# 데이터를 가져오는 방법에 대한 선택.

#### **API 레이어**
- API는 앱 코드와 DB 사이의 중간 계층. 
- API 를 제공하는 타사 서비스를 이용하는 경우.
- 클라이언트에서 데이터를 가져오는 경우, 데이터베이스 비밀이 클라이언트에 노출되는 것을 방지하기 위해 서버에서 실행되는 API 계층 필요.

#### **데이터베이스 쿼리.**
- Full Stack 앱을 생성할 때, DB와 상호 작용하는 로직도 작성해야 함.
		- RDBS의 경우 Postgres처럼 SQL이나 ORM을 사용하여 이 작업을 수행해야 함 Like Prisma
- 쿼리를 작성해야 하는 몇 가지 경우.
	- API 엔드포인트를 생성 할 때 DB와 상호작용하는 로직 작성해야함.
	- React Server Component (*fetching data on the server*)를 사용하는 경우, API 계층을 건너뛰고 데이터베이스 비밀이 클라이언트에 노출 될 위험 없이 DB에 직접 쿼리할 수 있음.

# NextJs는 React Server Component를 사용.

- 필요 한 경우 client Component를 선택 작성 할 수 있음.
- **React Server Component**를 사용할 때의 몇 가지 이점.
		- 서버 컴포넌트는 서버에서 실행되므로 비용이 많이 드는 logic, data fetch 는 서버에서 실행하고 결과만 클라이언트 단으로 전송.
		- 서버 컴포넌트는 Promise를 지원, fetch와 같은 비동기 작업을 위한 간단한 솔루션을 제공. async/ await에 접근하지 않고도 useEffect, useState 사용 가능.
		- 서버 컴포넌트는 서버에서 실행되기 때문에, 별도의 API 계층 없이 DB에 직접 쿼리 할 수 있음.

# Protect SQL Injection (*SQL 주입 방지*)
- Vercel/postgres/sdk 는 매개 변수를 추출하여 배열에 추가.
- SDK는 쿼리 문자열과 매개변수 배열을 PostgresSQL 서버로 전송, 이를 매개변수화 된 쿼리 라고 하는데, 이는 최신 JS SQL 라이브러리의 일반적인 패턴.
- Postgres 서버는 매개변수를 삭제하고 이를 쿼리에 삽입.
- 쿼리 실행 완료.


# Request Waterfalls *요청 폭포수*

- *폭포수* : 이전 요청의 완료에 따라 달라지는 일련의 네트워크 요청.
- 데이터 가져오기의 경우 각 요청은 이전 요청이 데이터를 반환한 후에만 시작할 수 있음.
![[Pasted image 20231109123320.png]]
#Sequential #Parallel

폭포수를 사용하는 경우: 이전 데이터를 가져온 후, 그 결과를 가지고 조회해야 하는 경우 ex) 유저 ID 조회 후, 게시글 목록 조회

# 병렬 데이터 가져오기.
- 폭포수를 방지하는 일반적인 방법은 모든 요청을 동시에 병렬적으로 실행하는 것.
- JS 에서는 Promise.all() 또는 Promise.allSettled()를 이용해 모든 약속을 동시에 시작하는 기능을 제공.

-  Promise.all()을 사용하면, 각각의 쿼리가 병렬로 실행되고, 모든 쿼리가 완료될 때까지 기다린다.
-  Promise.allSettled()를 사용하면, 키가 포함된 객체 배열을 반환할 수 있으므로, 컴포넌트에 전달하기 전까지 Promise가 완료
- 혹은 거부 여부를 확인 할 수 있음. Error handling에 유용.

- 장점
	- 모든 데이터 가져오기를 동시에 실행시 성능 향상 기대.
	- 기본 JavaScript 패턴이므로 모든 라이브러리나 프레임워크에 적용 가능.
- 단점.
	- 하나의 데이터 요청이 다른 모든 요청보다 느리다면?