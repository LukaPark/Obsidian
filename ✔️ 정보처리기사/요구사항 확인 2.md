
**유스케이스 다이어그램**
- *Use Case Diagram*은 사용자와 다른 외부 시스템들이 **개발될 시스템을 이용해 수행 할 수 있는 기능을**
- **사용자의 관점에서 표현**

**유스케이스 다이어그램의 구성 요소**
	1. **시스템 / 시스템 범위** *System, System Scope* : 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현한 것.
	2. **액터** *Actor* : **시스템과 상호작용을 하는 모든 외부 요소**, 주로 **사람이나 외부 시스템**을 의미함.
		- **주액터**: 시스템을 사용 함으로써 이득을 얻는 대상. 주로 **사람**
		- **부액터**: 주액터의 목적 달성을 위해 시스템에 **서비스를 제공하는 외부 시스템**. **조직**이나 **기관**
	3. **유스케이스** _Use Case_ : 사용자가 보는 관점에서 시스템이 액터에게 제공하는 **서비스나 기능**
	4. **관계** _Relationship_ : 유스케이스 다이어그램에서 관계는 **액터** 와 **유스케이스**, **유스케이스** 와 **유스케이스** 사이에서 나타날 수 있음.
		- **유스케이스에서 나타 날 수 있는 관계**
			- 포함(_include_), 확장 (_extends_), 일반화 (_generalize_) 관계

> 액터 : 대상 시스템과 상호작용을 하는 사람이나 다른 시스템에 의한 역할을 표현하는 요소.

 **포함 관계**
- 두 개 이상의 유스케이스에 **공통적으로 적용되는 기능**을 **별도로 분리**하여 **새로운 유스케이스로 만든 경우**. 원래의 유스케이스와 새롭게 분리된 유스케이스와의 관계를 포함 관계라고 함.
- 원래의 유스케이스에서 새롭게 만든 포함되는 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 "<<"include">>" 라고 표현함

**확장 관계**
- 유스케이스가 **특정 조건에 부합**되어 유스케이스의 **기능이 확장**될 때 원래의 유스케이스와 확장된 유스케이스와의 관계를 **확장 관계**라고 함
- 확장될 유스케이스에서 원래의 유스케이스 쪽으로 점선 화살표를 연결한 후 화살표 위에 "<<"extends">>"라고 표현

-> 기본 유스케이스 수행시 특별한 조건을 만족할 때 수행하는 유스케이스 -> 확장 관계

## 활동 다이어그램

- 활동 다이어그램은 사용자의 관점에서 시스템이 수행하는 기능을 **처리 흐름**에 따라 순서대로 표현한 것.
- **활동 다이어그램의 구성요소**
	- 액션 : 더 이상 분해 할 수 없는 단일 작업
	- 액티비티: 몇 개의 액션으로 분리될 수 있는 작업
	- 시작 노드: 액션이나 액티비티가 시작됨을 표현
	- 종료 노드: 액티비티 안의 모든 흐름이 종료됨을 표현
	- 조건(판단) 노드: 조건에 따라 제어의 흐름이 분리됨을 표현, 들어오는 제어 흐름은 한가지지만 나가는 제어 흐름은 여러가지.
	- 병합 노드: 여러 경로의 흐름이 하나로 합쳐짐을 표현한 것. 들어오는 제어 흐름은 여러가지지만 나가는 제어 흐름은 한가지.
	- 포크(Fork) 노드 : 액티비티의 흐름이 분리되어 수행됨을 표현. 들어오는 액티비티 흐름은 한개이고 나가는 액티비티 흐름은 여러 개.
	- 조인(Join) 노드: 분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현. 들어오는 액티비티 흐름은 여러개지만 나가는 액티비티 흐름은 한가지
	- 스윔레인: 액티비티 수행을 담당하는 주체를 구분하는 선. 가로 또는 세로 실선을 그어 구분


## 클래스 다이어그램
- **클래스와 클래스가 가지는 속성** , **클래스 사이의 관계를 표현**

**클래스 다이어그램의 구성요소**
- 클래스 
	- 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현
	- 일반적으로 3개의 구획(Compartment)으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기
	- **속성**: 클새스의 상태나 정보를 표현
	- **오퍼레이션**: 클래스가 수행할 수 있는 동작으로, 함수(메소드)라고도 함.
- 제약 조건:
	- 속성에 입력될 값에 대한 제약 조건이나 메소드 수행 전후에 지정해야 할 조건이 있다면 이를 적음.
	- 클래스 안에 제약조건을 기술할 때는 중괄호 {} 를 이용해야 함
- 관계 :
	- 관계는 클래스와 클래스 사이의 연관성을 표현
	- 클래스 다이어그램에 표현하는 관계에는 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있음.
	-

**연관 클래스**
- 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있을 경우 생성하는 클래스.
- 두 클래스의 연관 관계를 표현하는 선의 가운데로부터 점선을 연관 클래스로 이어 표현
- 연관 클래스의 이름은 연관 관계의 이름을 이용해 지정


**순차 다이어그램**
- **시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정을 그림으로 표현**

**순차 다이어그램의 구성요소**
- 액터 : 시스템으로 부터 서비스를 요청하는 외부 요소. **사람이나 외부 시스템**을 의미
- 객체 : 메시지를 주고 받는 **주체**
- 생명선: 객체가 메모리에 존재하는 기간. 객체 아래쪽에 점선을 그어 표현, 객체 소멸(X) 가 표현된 기간까지 생존
- 실행 상자: 객체가 메세지를 주고 받으며 구동되고 있음을 표현
- 메세지 : 객체가 상호 작용을 위해 주고 받는 메세지
- 객체 소멸: 해당 객체가 더 이상 메모리에 존재하지 않음을 표현
- 프레임: 다이어그램의 전체 또는 일부를 묶어 표현한 것.

## 커뮤니케이션 다이어그램
- 시스템이나 객체들이 메시지를 주고받으며 상호작용하는 과정과 객체들 간의 **연관성**을 그림으로 표현.

**구성요소**
- 액터 : 사람이나 외부 시스템
- 객체 : 메시지를 주고 받는 주체
- **링크**: 객체들간의 관계를 표현한 것. 액터와 객체, 객체와 객체간에 실선을 그어 표현
- 메시지 : 객체가 상호작용을 위해 주고받는 메세지. 화살표의 방향을 메시지를 받는 쪽을 향함. 일정한 순서에 의해 처리되는 메세지의 경우 숫자로 순서를 표시

> 시간의 흐름에 따라 상호작용하는 과정을 액터, 객체, 링크, 메시지 등의 요소를 사용해 그림으로 표현
> 동작에 참여하는 객체들이 주고받는 메세지를 표현. 메세지 뿐만 아니라 객체들간의 관계까지 표현

## 상태 다이어그램
- 객체들 사이에 발생하는 **이벤트**에 의한 객체들의 상태 변화를 그림으로 표현
 
**구성요소**
- 상태: 객체의 상태
- 시작 상태: 상태의 시작
- 종료 상태: 상태의 종료
- 상태 전환: 상태 사이의 흐름. 변화를 화살표로 표현
- 이벤트: 상태에 변화를 주는 현상, 이벤트에는 조건, 외부 신호, 시간의 흐름 등.
- 프레임: 상태 다이어그램의 범위를 표현

> 상태 다이어그램 ->**이벤트**

## 패키지 다이어그램
- 유스케이스나 클래스 등의 **요소들을 그룹화한 패키지** 간의 의존 관계를 표현
**구성요소**
- 패키지 : 객체들을 그룹화 한 것.
	- 단순 표기법: 패키지 안에 패키지 이름만 표현
	- 확장 표기법: 패키지 안에 요소까지 표현
- 객체 : 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 표현 될 수 있는 다양한 요소들
- 의존 관계 
	- 패키지와 패키지 혹은 패키지와 객체 간을 점선 화살표로 연결하여 표현.
	- 스테레오 타입을 이용해 의존 관계를 구체적으로 표현 할 수 있음.
	- 의존 관계의 표현 형태는 사용자가 임의로 작성할 수 있으며, 대표적으로 import 와 access 가 사용.
	- "<<"import">>" : 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계
	- "<<"access">>": 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계

> 스테레오 타입: UML에서 표현하는 기본 기능외에 추가적인 기능을 표현하는 형태

## 구조적 방법론
- 정형화 된 분석 절차에 따라 **사용자의 요구사항을 파악하여 문서화하는 처리(Process) 중심의 방법론**
- 이해가 쉽고 검증이 가능한 프로그램 코드를 생성하는 것이 목적.
- 구조적 방법론의 **개발 절차**
	- 타당성 검토 단계 -> 계획 단계 -> 요구사항 단계 -> 설계 단계 -> 구현 단계 -> 시험 단계 -> 운용/유지보수 단계

> 정형화된 분석 절차에 따라 사용자의 요구사항을 파악하고. 문서화 하는 체계적 분석 방법. / 자료 흐름도, 자료 사전, 소단위 명세서의 특징을 갖음. 소프트웨어 개발방법론
> **구조적 방법론**

## 컴포넌트 기반 방법론
- 컴포넌트 기반 방법론 (CBD; Component Based Design) 은 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론.
- 컴포넌트의 재사용(Reusability)이 가능하여 시간과 노력을 절감할 수 있다.
- 컴포넌트 기반 방법론의 **개발 절차**
	- 개발 준비 단계 -> 분석 단계 -> 설계 단계 -> 구현 단계 -> 테스트 단계 -> 전개 단계 -> 인도 단계

> 소프트웨어 개발 방법론.
> 기존의 시스템이나 소프트웨러를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 소프트웨어 개발 방법론.
> 특징 
> 	1. 개발 기간 단축으로 인한 생산성 향상
> 	2. 새로운 기능 추가가 쉬운 확장성
> 	3. 소프트웨어 재사용이 가능.

#### 소프트웨어 재사용
- 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것.
- 소프트웨어 **재사용 방법**
	- **합성 중심** *Composition-Based* : 전자 칩과 같은 소프트웨어 부품. 즉 블록을 만들어 끼워 맞춰 소프트웨어를 완성시키는 방법. **블록 구성 방법** 이라고도 함.
	- **생성 중심** _Generation-Based_ : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법. **패턴 구성 방법** 이라고도 함.

> **소프트 웨어 재사용 방법.**
> 블록 구성 방법. **합성 중심**
> 패턴 구성 방법. **생성 중심**

## CASE

- _Computer Aided Software Engineering_ 
- 소프트웨어 개발 과정에서 사용되는 요구분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 통해 **자동화 하는것**
- 표준화된 개발 환경 구축 및 문서 자도오하 기능을 제공
- 작업 과정 및 데이터 공유를 통해 작업자 간 커뮤니케이션을 증대.
- **주요 기능**
	- 소프트웨어 생명 주기 전 단계의 연결
	- 다양한 소프트웨어 개발 모형 지원
	- 그래픽 지원
> CASE

## LOC 기법
- _source Line Of Code, 원시 코드 라인 수_ 기법.
- SW 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법
- **산정 공식**
	- 노력(인월) = 개발 기간 * 투입 인원 = LOC / 1인당 월 평균 생산 코드 라인 수
	- 개발 비용 = 노력(인월) * 단위비용 (1인당 월 평균 인건 비)
	- 개발 기간 = 노력(인월) / 투입 인원
	- 생산성 = LOC / 노력(인월)


## 수학적 산정 기법
- 수학식 산정 기법은 **상향식 비용 산정 기법**. **경험적 추정 모형, 실험적 추정 모형** 이라고도 함.
- 개발 비용 산정의 **자동화**를 목표.
- 주요 수학적 산정 기법들
	- COCOMO 모형
	- Putnam 모형
	- 기능 점수(Function-Point) 모형

**COCOMO**
- _COnstructive COst MOdel_ : 원시 프로그램의 규모인 **LOC 에 의한 비용 산정 기법**
- 개발할 소프트웨어의 규모(LOC)를 예측한 후 이를 **SW 종류에 따라** 다르게 책정되는 **비용 산정 방정식**에 대입
- 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력 (**Man-Month**)로 나타냄
- 보헴 (Boehm) 이 제안
- 비용 산정 유형 
	- Organic Mode, Embedded Mode, Semi-Detached Mode 가 있음

	**조직형; Organic Mode** 
	- 기관 내부에서 개발된 중-소 규모의 SW
	- 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용 등의 5만(50KDSI) 라인 이하의 소프트웨어를 개발하는 유형
	- 사무 처리용, 업무용, 과학용 응용 소프트웨어 개발에 적합
- **반 분리형; Semi-Detached Mode**
	- 조직형과 내장형의 중간형 소프트웨어
	- 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 30만(300KDSI)라인 이하의 소프트웨어를 개발하는 유형
	- 컴파일러, 인터프리터 같은 유틸리티 개발에 적합
- **내장형; Embedded Mode**
	- 초대형 규모의 소프트웨어
	- 트랜잭션 처리 시스템이나 운영체제 등의 30만(300KDSI)라인 이상의 소프트웨어를 개발하는 유형
	- 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합
> Embedded Mode > Semi-Detached Mode > Organic Mode


## Putnam 모형
- **SW 생명주기 전 과정 동안에 사용 될 노력의 분포를 예상하는 모형**
- 푸트남(Putnam)이 제안. **생명 주기 예측 모형** 이라고도 함
- 시간에 따라 함수로 표현되는 **Rayleigh-Norden 곡선의 노력 분포도**를 기본으로 함

## 기능 점수 모형; Function-Point
- **소프트웨어의 기능을 증대시키는 요인별**로 가중치를 부여하고. 요인 별 가중치를 합산하여 총 기능 점수를 산출 -> 총 기능 점수와 영향도를 이용하여 **기능 점수** 를 산정한 후 이를 이용하여 **비용을 산정하는 기법**
- 기능 증대 요인
	- 자료 입력 (입력 양식)
	- 정보 출력 (출력 보고서)
	- 명령어 (사용자 질의 수)
	- 데이터 파일
	- 필요한 외부 루틴과의 인터페이스


> **비용 산정 자동화 추정 도구**
> - **SLIM** : Rayleigh-Norden 곡선과 Putnam 예측 모형을 기초로 하여 개발된 자동화 측정 도구
> - **ESTIMACS** : 다양한 프로젝트와 개인별 요소를 수용하도록 **FP 모형**을 기초로 하여 개발 된 자동화 추정 도구


> SLIM, ESTIMACS

## PERT
- _Program Evaluation and Review Technique_
- **프로그램 평가 및 검토 기술**은 프로젝트에 필요한 전체 **작업의 상호 관계**를 표시하는 **네트워크**
- **결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등**을 알 수 있음.
- 각 작업 별로 단계를 나누어 종료 시기를 결정
	- 낙관적인 경우
	- 가능성이 있는 경우
	- 비관적인 경우
> 전체 작업의 상호 관계를 표시하는 **네트워크**.
> 작업들 간의 상호 관련성, 결정 경로, 경계 시간, 자원 할당 등을 제시하는 **프로젝트 일정 계획 기법**.

## CPM
- _Critical Path Method_ _임계 경로 기법_ 은 프로젝트 완성에 필요한 **작업을 나열**. 작업에 필요한 **소요시간을 예측 하는데 사용하는 기법**
- CPM은 노드와 간선으로 구성된 네트워크. **노드**는 **작업**, **간선**은 작업 사이의 **전후 의존 관계**를 나타냄


## 간트 차트
- 프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 **작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표**, 수평 막대의 길이는 각 작업의 기간을 나타냄.
- **시간선 (Time-Line) 차트** 라고도 함
- 중간 목표 미달성 시 그 이유와 기간을 예측 할 수 있게 함.
- 자원 배치와 인원 계획에 유용하게 사용

## ISO/IEC 12207
- **ISO**(국제 표준화 기구) 에서 만든 **표준 소프트웨어 생명 주기 프로세스**
- 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 **소프트웨어 생명 주기 표준**을 제공
- **구분**
	- 기본 생명 주기 프로세스 : 획득, 공급, 개발, 운영, 유지보수 프로세스
	- 지원 생명 주기 프로세스: 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스
	- 조직 생명 주기 프로세스: 관리, 기반 구조, 훈련, 개선 프로세스.
- 
